/* soapStub.h
   Generated by gSOAP 2.8.100 for client_collect.h

gSOAP XML Web services tools
Copyright (C) 2000-2020, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://tempuri.org/"
#define SOAP_NAMESPACE_OF_ns2	"http://schemas.microsoft.com/2003/10/Serialization/"
#define SOAP_NAMESPACE_OF_ns3	"http://schemas.datacontract.org/2004/07/Mx.Broker.Std.Request.Interface.PostTapingCollectShuttle01"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208100
# error "GSOAP VERSION 208100 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* client_collect.h:444 */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusType
#define SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusType (66)
/* ns3:PostTapingCollectShuttleMissionStatusType */
enum ns3__PostTapingCollectShuttleMissionStatusType {
	ns3__PostTapingCollectShuttleMissionStatusType__Ok = 0,
	ns3__PostTapingCollectShuttleMissionStatusType__Nok = 1
};
#endif

/* client_collect.h:461 */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleRunningModeType
#define SOAP_TYPE_ns3__PostTapingCollectShuttleRunningModeType (68)
/* ns3:PostTapingCollectShuttleRunningModeType */
enum ns3__PostTapingCollectShuttleRunningModeType {
	ns3__PostTapingCollectShuttleRunningModeType__Manual = 0,
	ns3__PostTapingCollectShuttleRunningModeType__Rest = 1,
	ns3__PostTapingCollectShuttleRunningModeType__MissionInProgress = 2,
	ns3__PostTapingCollectShuttleRunningModeType__Default = 3
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* client_collect.h:172 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (11)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class xsd__anyType;	/* client_collect.h:165 */
class xsd__base64Binary;	/* client_collect.h:175 */
class xsd__ID__;	/* client_collect.h:193 */
class xsd__IDREF__;	/* client_collect.h:203 */
class xsd__QName__;	/* client_collect.h:210 */
class xsd__anyURI__;	/* client_collect.h:220 */
class xsd__base64Binary__;	/* client_collect.h:227 */
class xsd__boolean_;	/* client_collect.h:234 */
class xsd__byte__;	/* client_collect.h:241 */
class xsd__dateTime_;	/* client_collect.h:248 */
class xsd__decimal__;	/* client_collect.h:258 */
class xsd__double_;	/* client_collect.h:265 */
class xsd__duration__;	/* client_collect.h:275 */
class xsd__float_;	/* client_collect.h:282 */
class xsd__int_;	/* client_collect.h:289 */
class xsd__long_;	/* client_collect.h:296 */
class xsd__short_;	/* client_collect.h:303 */
class xsd__string_;	/* client_collect.h:310 */
class xsd__unsignedByte__;	/* client_collect.h:317 */
class xsd__unsignedInt_;	/* client_collect.h:324 */
class xsd__unsignedLong_;	/* client_collect.h:331 */
class xsd__unsignedShort_;	/* client_collect.h:338 */
class ns2__char__;	/* client_collect.h:400 */
class ns2__duration__;	/* client_collect.h:414 */
class ns2__guid__;	/* client_collect.h:427 */
class ns3__PostTapingCollectShuttleMissionStatusType_;	/* client_collect.h:452 */
class ns3__PostTapingCollectShuttleRunningModeType_;	/* client_collect.h:471 */
class _ns1__TapingOutputConveyorNumber;	/* client_collect.h:351 */
class _ns1__TapingOutputConveyorNumberResponse;	/* client_collect.h:353 */
class _ns1__MissionStatus;	/* client_collect.h:355 */
class _ns1__MissionStatusResponse;	/* client_collect.h:357 */
class _ns1__ReportRunningMode;	/* client_collect.h:359 */
class _ns1__ReportRunningModeResponse;	/* client_collect.h:361 */
class ns3__PostTapingCollectShuttleTapingOutputConveyorRequest;	/* client_collect.h:363 */
class ns3__PostTapingCollectShuttleMissionStatusRequest;	/* client_collect.h:365 */
class ns3__PostTapingCollectShuttleReportRunningModeRequest;	/* client_collect.h:367 */
struct __ns1__TapingOutputConveyorNumber;	/* client_collect.h:958 */
struct __ns1__MissionStatus;	/* client_collect.h:1028 */
struct __ns1__ReportRunningMode;	/* client_collect.h:1098 */

/* client_collect.h:165 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (8)
/* simple XML schema type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyType); }
      public:
        /// Constructor with default initializations
        xsd__anyType() : __item(), soap() { }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:175 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (12)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:193 */
#ifndef SOAP_TYPE_xsd__ID__
#define SOAP_TYPE_xsd__ID__ (19)
/* simple XML schema type 'xsd:ID': */
class SOAP_CMAC xsd__ID__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:ID' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__ID__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__ID__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__ID__, default initialized and not managed by a soap context
        virtual xsd__ID__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__ID__); }
      public:
        /// Constructor with default initializations
        xsd__ID__() : __item() { }
        virtual ~xsd__ID__() { }
        /// Friend allocator used by soap_new_xsd__ID__(struct soap*, int)
        friend SOAP_FMAC1 xsd__ID__ * SOAP_FMAC2 soap_instantiate_xsd__ID__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:203 */
#ifndef SOAP_TYPE_xsd__IDREF__
#define SOAP_TYPE_xsd__IDREF__ (21)
/* simple XML schema type 'xsd:IDREF': */
class SOAP_CMAC xsd__IDREF__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:IDREF' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__IDREF__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__IDREF__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__IDREF__, default initialized and not managed by a soap context
        virtual xsd__IDREF__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__IDREF__); }
      public:
        /// Constructor with default initializations
        xsd__IDREF__() : __item() { }
        virtual ~xsd__IDREF__() { }
        /// Friend allocator used by soap_new_xsd__IDREF__(struct soap*, int)
        friend SOAP_FMAC1 xsd__IDREF__ * SOAP_FMAC2 soap_instantiate_xsd__IDREF__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:210 */
#ifndef SOAP_TYPE_xsd__QName__
#define SOAP_TYPE_xsd__QName__ (22)
/* simple XML schema type 'xsd:QName': */
class SOAP_CMAC xsd__QName__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:QName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__QName__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__QName__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__QName__, default initialized and not managed by a soap context
        virtual xsd__QName__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__QName__); }
      public:
        /// Constructor with default initializations
        xsd__QName__() : __item() { }
        virtual ~xsd__QName__() { }
        /// Friend allocator used by soap_new_xsd__QName__(struct soap*, int)
        friend SOAP_FMAC1 xsd__QName__ * SOAP_FMAC2 soap_instantiate_xsd__QName__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:220 */
#ifndef SOAP_TYPE_xsd__anyURI__
#define SOAP_TYPE_xsd__anyURI__ (24)
/* simple XML schema type 'xsd:anyURI': */
class SOAP_CMAC xsd__anyURI__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyURI' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyURI__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyURI__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyURI__, default initialized and not managed by a soap context
        virtual xsd__anyURI__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyURI__); }
      public:
        /// Constructor with default initializations
        xsd__anyURI__() : __item() { }
        virtual ~xsd__anyURI__() { }
        /// Friend allocator used by soap_new_xsd__anyURI__(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyURI__ * SOAP_FMAC2 soap_instantiate_xsd__anyURI__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:227 */
#ifndef SOAP_TYPE_xsd__base64Binary__
#define SOAP_TYPE_xsd__base64Binary__ (25)
/* simple XML schema type 'xsd:base64Binary': */
class SOAP_CMAC xsd__base64Binary__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary__, default initialized and not managed by a soap context
        virtual xsd__base64Binary__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary__); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary__() : __item() { }
        virtual ~xsd__base64Binary__() { }
        /// Friend allocator used by soap_new_xsd__base64Binary__(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary__ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:234 */
#ifndef SOAP_TYPE_xsd__boolean_
#define SOAP_TYPE_xsd__boolean_ (26)
/* simple XML schema type 'xsd:boolean': */
class SOAP_CMAC xsd__boolean_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__boolean_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean_, default initialized and not managed by a soap context
        virtual xsd__boolean_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__boolean_); }
      public:
        /// Constructor with default initializations
        xsd__boolean_() : __item() { }
        virtual ~xsd__boolean_() { }
        /// Friend allocator used by soap_new_xsd__boolean_(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean_ * SOAP_FMAC2 soap_instantiate_xsd__boolean_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:241 */
#ifndef SOAP_TYPE_xsd__byte__
#define SOAP_TYPE_xsd__byte__ (28)
/* simple XML schema type 'xsd:byte': */
class SOAP_CMAC xsd__byte__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:byte' wrapped by this struct
        char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__byte__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__byte__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__byte__, default initialized and not managed by a soap context
        virtual xsd__byte__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__byte__); }
      public:
        /// Constructor with default initializations
        xsd__byte__() : __item() { }
        virtual ~xsd__byte__() { }
        /// Friend allocator used by soap_new_xsd__byte__(struct soap*, int)
        friend SOAP_FMAC1 xsd__byte__ * SOAP_FMAC2 soap_instantiate_xsd__byte__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:248 */
#ifndef SOAP_TYPE_xsd__dateTime_
#define SOAP_TYPE_xsd__dateTime_ (29)
/* simple XML schema type 'xsd:dateTime': */
class SOAP_CMAC xsd__dateTime_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__dateTime_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__dateTime_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime_, default initialized and not managed by a soap context
        virtual xsd__dateTime_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__dateTime_); }
      public:
        /// Constructor with default initializations
        xsd__dateTime_() : __item() { }
        virtual ~xsd__dateTime_() { }
        /// Friend allocator used by soap_new_xsd__dateTime_(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime_ * SOAP_FMAC2 soap_instantiate_xsd__dateTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:258 */
#ifndef SOAP_TYPE_xsd__decimal__
#define SOAP_TYPE_xsd__decimal__ (32)
/* simple XML schema type 'xsd:decimal': */
class SOAP_CMAC xsd__decimal__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:decimal' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__decimal__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__decimal__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__decimal__, default initialized and not managed by a soap context
        virtual xsd__decimal__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__decimal__); }
      public:
        /// Constructor with default initializations
        xsd__decimal__() : __item() { }
        virtual ~xsd__decimal__() { }
        /// Friend allocator used by soap_new_xsd__decimal__(struct soap*, int)
        friend SOAP_FMAC1 xsd__decimal__ * SOAP_FMAC2 soap_instantiate_xsd__decimal__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:265 */
#ifndef SOAP_TYPE_xsd__double_
#define SOAP_TYPE_xsd__double_ (33)
/* simple XML schema type 'xsd:double': */
class SOAP_CMAC xsd__double_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:double' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__double_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__double_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__double_, default initialized and not managed by a soap context
        virtual xsd__double_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__double_); }
      public:
        /// Constructor with default initializations
        xsd__double_() : __item() { }
        virtual ~xsd__double_() { }
        /// Friend allocator used by soap_new_xsd__double_(struct soap*, int)
        friend SOAP_FMAC1 xsd__double_ * SOAP_FMAC2 soap_instantiate_xsd__double_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:275 */
#ifndef SOAP_TYPE_xsd__duration__
#define SOAP_TYPE_xsd__duration__ (36)
/* simple XML schema type 'xsd:duration': */
class SOAP_CMAC xsd__duration__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:duration' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__duration__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__duration__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__duration__, default initialized and not managed by a soap context
        virtual xsd__duration__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__duration__); }
      public:
        /// Constructor with default initializations
        xsd__duration__() : __item() { }
        virtual ~xsd__duration__() { }
        /// Friend allocator used by soap_new_xsd__duration__(struct soap*, int)
        friend SOAP_FMAC1 xsd__duration__ * SOAP_FMAC2 soap_instantiate_xsd__duration__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:282 */
#ifndef SOAP_TYPE_xsd__float_
#define SOAP_TYPE_xsd__float_ (37)
/* simple XML schema type 'xsd:float': */
class SOAP_CMAC xsd__float_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:float' wrapped by this struct
        float __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__float_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__float_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__float_, default initialized and not managed by a soap context
        virtual xsd__float_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__float_); }
      public:
        /// Constructor with default initializations
        xsd__float_() : __item() { }
        virtual ~xsd__float_() { }
        /// Friend allocator used by soap_new_xsd__float_(struct soap*, int)
        friend SOAP_FMAC1 xsd__float_ * SOAP_FMAC2 soap_instantiate_xsd__float_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:289 */
#ifndef SOAP_TYPE_xsd__int_
#define SOAP_TYPE_xsd__int_ (39)
/* simple XML schema type 'xsd:int': */
class SOAP_CMAC xsd__int_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__int_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__int_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int_, default initialized and not managed by a soap context
        virtual xsd__int_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__int_); }
      public:
        /// Constructor with default initializations
        xsd__int_() : __item() { }
        virtual ~xsd__int_() { }
        /// Friend allocator used by soap_new_xsd__int_(struct soap*, int)
        friend SOAP_FMAC1 xsd__int_ * SOAP_FMAC2 soap_instantiate_xsd__int_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:296 */
#ifndef SOAP_TYPE_xsd__long_
#define SOAP_TYPE_xsd__long_ (40)
/* simple XML schema type 'xsd:long': */
class SOAP_CMAC xsd__long_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:long' wrapped by this struct
        LONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__long_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__long_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__long_, default initialized and not managed by a soap context
        virtual xsd__long_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__long_); }
      public:
        /// Constructor with default initializations
        xsd__long_() : __item() { }
        virtual ~xsd__long_() { }
        /// Friend allocator used by soap_new_xsd__long_(struct soap*, int)
        friend SOAP_FMAC1 xsd__long_ * SOAP_FMAC2 soap_instantiate_xsd__long_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:303 */
#ifndef SOAP_TYPE_xsd__short_
#define SOAP_TYPE_xsd__short_ (42)
/* simple XML schema type 'xsd:short': */
class SOAP_CMAC xsd__short_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:short' wrapped by this struct
        short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__short_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__short_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__short_, default initialized and not managed by a soap context
        virtual xsd__short_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__short_); }
      public:
        /// Constructor with default initializations
        xsd__short_() : __item() { }
        virtual ~xsd__short_() { }
        /// Friend allocator used by soap_new_xsd__short_(struct soap*, int)
        friend SOAP_FMAC1 xsd__short_ * SOAP_FMAC2 soap_instantiate_xsd__short_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:310 */
#ifndef SOAP_TYPE_xsd__string_
#define SOAP_TYPE_xsd__string_ (44)
/* simple XML schema type 'xsd:string': */
class SOAP_CMAC xsd__string_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__string_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string_, default initialized and not managed by a soap context
        virtual xsd__string_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__string_); }
      public:
        /// Constructor with default initializations
        xsd__string_() : __item() { }
        virtual ~xsd__string_() { }
        /// Friend allocator used by soap_new_xsd__string_(struct soap*, int)
        friend SOAP_FMAC1 xsd__string_ * SOAP_FMAC2 soap_instantiate_xsd__string_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:317 */
#ifndef SOAP_TYPE_xsd__unsignedByte__
#define SOAP_TYPE_xsd__unsignedByte__ (45)
/* simple XML schema type 'xsd:unsignedByte': */
class SOAP_CMAC xsd__unsignedByte__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:unsignedByte' wrapped by this struct
        unsigned char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedByte__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedByte__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedByte__, default initialized and not managed by a soap context
        virtual xsd__unsignedByte__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__unsignedByte__); }
      public:
        /// Constructor with default initializations
        xsd__unsignedByte__() : __item() { }
        virtual ~xsd__unsignedByte__() { }
        /// Friend allocator used by soap_new_xsd__unsignedByte__(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedByte__ * SOAP_FMAC2 soap_instantiate_xsd__unsignedByte__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:324 */
#ifndef SOAP_TYPE_xsd__unsignedInt_
#define SOAP_TYPE_xsd__unsignedInt_ (46)
/* simple XML schema type 'xsd:unsignedInt': */
class SOAP_CMAC xsd__unsignedInt_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:unsignedInt' wrapped by this struct
        unsigned int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedInt_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedInt_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedInt_, default initialized and not managed by a soap context
        virtual xsd__unsignedInt_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__unsignedInt_); }
      public:
        /// Constructor with default initializations
        xsd__unsignedInt_() : __item() { }
        virtual ~xsd__unsignedInt_() { }
        /// Friend allocator used by soap_new_xsd__unsignedInt_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedInt_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedInt_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:331 */
#ifndef SOAP_TYPE_xsd__unsignedLong_
#define SOAP_TYPE_xsd__unsignedLong_ (47)
/* simple XML schema type 'xsd:unsignedLong': */
class SOAP_CMAC xsd__unsignedLong_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:unsignedLong' wrapped by this struct
        ULONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedLong_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedLong_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedLong_, default initialized and not managed by a soap context
        virtual xsd__unsignedLong_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__unsignedLong_); }
      public:
        /// Constructor with default initializations
        xsd__unsignedLong_() : __item() { }
        virtual ~xsd__unsignedLong_() { }
        /// Friend allocator used by soap_new_xsd__unsignedLong_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedLong_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:338 */
#ifndef SOAP_TYPE_xsd__unsignedShort_
#define SOAP_TYPE_xsd__unsignedShort_ (49)
/* simple XML schema type 'xsd:unsignedShort': */
class SOAP_CMAC xsd__unsignedShort_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:unsignedShort' wrapped by this struct
        unsigned short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedShort_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedShort_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedShort_, default initialized and not managed by a soap context
        virtual xsd__unsignedShort_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__unsignedShort_); }
      public:
        /// Constructor with default initializations
        xsd__unsignedShort_() : __item() { }
        virtual ~xsd__unsignedShort_() { }
        /// Friend allocator used by soap_new_xsd__unsignedShort_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedShort_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedShort_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:400 */
#ifndef SOAP_TYPE_ns2__char__
#define SOAP_TYPE_ns2__char__ (61)
/* simple XML schema type 'ns2:char': */
class SOAP_CMAC ns2__char__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ns2:char' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_ns2__char__
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__char__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__char__, default initialized and not managed by a soap context
        virtual ns2__char__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__char__); }
      public:
        /// Constructor with default initializations
        ns2__char__() : __item() { }
        virtual ~ns2__char__() { }
        /// Friend allocator used by soap_new_ns2__char__(struct soap*, int)
        friend SOAP_FMAC1 ns2__char__ * SOAP_FMAC2 soap_instantiate_ns2__char__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:414 */
#ifndef SOAP_TYPE_ns2__duration__
#define SOAP_TYPE_ns2__duration__ (63)
/* simple XML schema type 'ns2:duration': */
class SOAP_CMAC ns2__duration__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ns2:duration' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ns2__duration__
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__duration__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__duration__, default initialized and not managed by a soap context
        virtual ns2__duration__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__duration__); }
      public:
        /// Constructor with default initializations
        ns2__duration__() : __item() { }
        virtual ~ns2__duration__() { }
        /// Friend allocator used by soap_new_ns2__duration__(struct soap*, int)
        friend SOAP_FMAC1 ns2__duration__ * SOAP_FMAC2 soap_instantiate_ns2__duration__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:427 */
#ifndef SOAP_TYPE_ns2__guid__
#define SOAP_TYPE_ns2__guid__ (65)
/* simple XML schema type 'ns2:guid': */
class SOAP_CMAC ns2__guid__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ns2:guid' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_ns2__guid__
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__guid__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__guid__, default initialized and not managed by a soap context
        virtual ns2__guid__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__guid__); }
      public:
        /// Constructor with default initializations
        ns2__guid__() : __item() { }
        virtual ~ns2__guid__() { }
        /// Friend allocator used by soap_new_ns2__guid__(struct soap*, int)
        friend SOAP_FMAC1 ns2__guid__ * SOAP_FMAC2 soap_instantiate_ns2__guid__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:452 */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusType_
#define SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusType_ (67)
/* simple XML schema type 'ns3:PostTapingCollectShuttleMissionStatusType': */
class SOAP_CMAC ns3__PostTapingCollectShuttleMissionStatusType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ns3:PostTapingCollectShuttleMissionStatusType' wrapped by this struct
        enum ns3__PostTapingCollectShuttleMissionStatusType __item;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusType_
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PostTapingCollectShuttleMissionStatusType_, default initialized and not managed by a soap context
        virtual ns3__PostTapingCollectShuttleMissionStatusType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__PostTapingCollectShuttleMissionStatusType_); }
      public:
        /// Constructor with default initializations
        ns3__PostTapingCollectShuttleMissionStatusType_() : __item() { }
        virtual ~ns3__PostTapingCollectShuttleMissionStatusType_() { }
        /// Friend allocator used by soap_new_ns3__PostTapingCollectShuttleMissionStatusType_(struct soap*, int)
        friend SOAP_FMAC1 ns3__PostTapingCollectShuttleMissionStatusType_ * SOAP_FMAC2 soap_instantiate_ns3__PostTapingCollectShuttleMissionStatusType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:471 */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleRunningModeType_
#define SOAP_TYPE_ns3__PostTapingCollectShuttleRunningModeType_ (69)
/* simple XML schema type 'ns3:PostTapingCollectShuttleRunningModeType': */
class SOAP_CMAC ns3__PostTapingCollectShuttleRunningModeType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ns3:PostTapingCollectShuttleRunningModeType' wrapped by this struct
        enum ns3__PostTapingCollectShuttleRunningModeType __item;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PostTapingCollectShuttleRunningModeType_
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__PostTapingCollectShuttleRunningModeType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PostTapingCollectShuttleRunningModeType_, default initialized and not managed by a soap context
        virtual ns3__PostTapingCollectShuttleRunningModeType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__PostTapingCollectShuttleRunningModeType_); }
      public:
        /// Constructor with default initializations
        ns3__PostTapingCollectShuttleRunningModeType_() : __item() { }
        virtual ~ns3__PostTapingCollectShuttleRunningModeType_() { }
        /// Friend allocator used by soap_new_ns3__PostTapingCollectShuttleRunningModeType_(struct soap*, int)
        friend SOAP_FMAC1 ns3__PostTapingCollectShuttleRunningModeType_ * SOAP_FMAC2 soap_instantiate_ns3__PostTapingCollectShuttleRunningModeType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:351 */
#ifndef SOAP_TYPE__ns1__TapingOutputConveyorNumber
#define SOAP_TYPE__ns1__TapingOutputConveyorNumber (51)
/* complex XML schema type 'ns1:TapingOutputConveyorNumber': */
class SOAP_CMAC _ns1__TapingOutputConveyorNumber {
      public:
        /// Optional element 'ns1:request' of XML schema type 'ns3:PostTapingCollectShuttleTapingOutputConveyorRequest'
        ns3__PostTapingCollectShuttleTapingOutputConveyorRequest *request;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__TapingOutputConveyorNumber
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__TapingOutputConveyorNumber; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__TapingOutputConveyorNumber, default initialized and not managed by a soap context
        virtual _ns1__TapingOutputConveyorNumber *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__TapingOutputConveyorNumber); }
      public:
        /// Constructor with default initializations
        _ns1__TapingOutputConveyorNumber() : request(), soap() { }
        virtual ~_ns1__TapingOutputConveyorNumber() { }
        /// Friend allocator used by soap_new__ns1__TapingOutputConveyorNumber(struct soap*, int)
        friend SOAP_FMAC1 _ns1__TapingOutputConveyorNumber * SOAP_FMAC2 soap_instantiate__ns1__TapingOutputConveyorNumber(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:353 */
#ifndef SOAP_TYPE__ns1__TapingOutputConveyorNumberResponse
#define SOAP_TYPE__ns1__TapingOutputConveyorNumberResponse (52)
/* complex XML schema type 'ns1:TapingOutputConveyorNumberResponse': */
class SOAP_CMAC _ns1__TapingOutputConveyorNumberResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__TapingOutputConveyorNumberResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__TapingOutputConveyorNumberResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__TapingOutputConveyorNumberResponse, default initialized and not managed by a soap context
        virtual _ns1__TapingOutputConveyorNumberResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__TapingOutputConveyorNumberResponse); }
      public:
        /// Constructor with default initializations
        _ns1__TapingOutputConveyorNumberResponse() : soap() { }
        virtual ~_ns1__TapingOutputConveyorNumberResponse() { }
        /// Friend allocator used by soap_new__ns1__TapingOutputConveyorNumberResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__TapingOutputConveyorNumberResponse * SOAP_FMAC2 soap_instantiate__ns1__TapingOutputConveyorNumberResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:355 */
#ifndef SOAP_TYPE__ns1__MissionStatus
#define SOAP_TYPE__ns1__MissionStatus (53)
/* complex XML schema type 'ns1:MissionStatus': */
class SOAP_CMAC _ns1__MissionStatus {
      public:
        /// Optional element 'ns1:request' of XML schema type 'ns3:PostTapingCollectShuttleMissionStatusRequest'
        ns3__PostTapingCollectShuttleMissionStatusRequest *request;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__MissionStatus
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__MissionStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__MissionStatus, default initialized and not managed by a soap context
        virtual _ns1__MissionStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__MissionStatus); }
      public:
        /// Constructor with default initializations
        _ns1__MissionStatus() : request(), soap() { }
        virtual ~_ns1__MissionStatus() { }
        /// Friend allocator used by soap_new__ns1__MissionStatus(struct soap*, int)
        friend SOAP_FMAC1 _ns1__MissionStatus * SOAP_FMAC2 soap_instantiate__ns1__MissionStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:357 */
#ifndef SOAP_TYPE__ns1__MissionStatusResponse
#define SOAP_TYPE__ns1__MissionStatusResponse (54)
/* complex XML schema type 'ns1:MissionStatusResponse': */
class SOAP_CMAC _ns1__MissionStatusResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__MissionStatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__MissionStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__MissionStatusResponse, default initialized and not managed by a soap context
        virtual _ns1__MissionStatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__MissionStatusResponse); }
      public:
        /// Constructor with default initializations
        _ns1__MissionStatusResponse() : soap() { }
        virtual ~_ns1__MissionStatusResponse() { }
        /// Friend allocator used by soap_new__ns1__MissionStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__MissionStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__MissionStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:359 */
#ifndef SOAP_TYPE__ns1__ReportRunningMode
#define SOAP_TYPE__ns1__ReportRunningMode (55)
/* complex XML schema type 'ns1:ReportRunningMode': */
class SOAP_CMAC _ns1__ReportRunningMode {
      public:
        /// Optional element 'ns1:request' of XML schema type 'ns3:PostTapingCollectShuttleReportRunningModeRequest'
        ns3__PostTapingCollectShuttleReportRunningModeRequest *request;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportRunningMode
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ReportRunningMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportRunningMode, default initialized and not managed by a soap context
        virtual _ns1__ReportRunningMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ReportRunningMode); }
      public:
        /// Constructor with default initializations
        _ns1__ReportRunningMode() : request(), soap() { }
        virtual ~_ns1__ReportRunningMode() { }
        /// Friend allocator used by soap_new__ns1__ReportRunningMode(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportRunningMode * SOAP_FMAC2 soap_instantiate__ns1__ReportRunningMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:361 */
#ifndef SOAP_TYPE__ns1__ReportRunningModeResponse
#define SOAP_TYPE__ns1__ReportRunningModeResponse (56)
/* complex XML schema type 'ns1:ReportRunningModeResponse': */
class SOAP_CMAC _ns1__ReportRunningModeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ReportRunningModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__ReportRunningModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ReportRunningModeResponse, default initialized and not managed by a soap context
        virtual _ns1__ReportRunningModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__ReportRunningModeResponse); }
      public:
        /// Constructor with default initializations
        _ns1__ReportRunningModeResponse() : soap() { }
        virtual ~_ns1__ReportRunningModeResponse() { }
        /// Friend allocator used by soap_new__ns1__ReportRunningModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ReportRunningModeResponse * SOAP_FMAC2 soap_instantiate__ns1__ReportRunningModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:363 */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleTapingOutputConveyorRequest
#define SOAP_TYPE_ns3__PostTapingCollectShuttleTapingOutputConveyorRequest (57)
/* complex XML schema type 'ns3:PostTapingCollectShuttleTapingOutputConveyorRequest': */
class SOAP_CMAC ns3__PostTapingCollectShuttleTapingOutputConveyorRequest : public xsd__anyType {
      public:
        /// Optional element 'ns3:TapingOutputConveyorNumber' of XML schema type 'xsd:int'
        int *TapingOutputConveyorNumber;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PostTapingCollectShuttleTapingOutputConveyorRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__PostTapingCollectShuttleTapingOutputConveyorRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PostTapingCollectShuttleTapingOutputConveyorRequest, default initialized and not managed by a soap context
        virtual ns3__PostTapingCollectShuttleTapingOutputConveyorRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__PostTapingCollectShuttleTapingOutputConveyorRequest); }
      public:
        /// Constructor with default initializations
        ns3__PostTapingCollectShuttleTapingOutputConveyorRequest() : TapingOutputConveyorNumber() { }
        virtual ~ns3__PostTapingCollectShuttleTapingOutputConveyorRequest() { }
        /// Friend allocator used by soap_new_ns3__PostTapingCollectShuttleTapingOutputConveyorRequest(struct soap*, int)
        friend SOAP_FMAC1 ns3__PostTapingCollectShuttleTapingOutputConveyorRequest * SOAP_FMAC2 soap_instantiate_ns3__PostTapingCollectShuttleTapingOutputConveyorRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:365 */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusRequest
#define SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusRequest (58)
/* complex XML schema type 'ns3:PostTapingCollectShuttleMissionStatusRequest': */
class SOAP_CMAC ns3__PostTapingCollectShuttleMissionStatusRequest : public xsd__anyType {
      public:
        /// Optional element 'ns3:MissionNumber' of XML schema type 'xsd:int'
        int *MissionNumber;
        /// Optional element 'ns3:MissionStatus' of XML schema type 'ns3:PostTapingCollectShuttleMissionStatusType'
        enum ns3__PostTapingCollectShuttleMissionStatusType *MissionStatus;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PostTapingCollectShuttleMissionStatusRequest, default initialized and not managed by a soap context
        virtual ns3__PostTapingCollectShuttleMissionStatusRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__PostTapingCollectShuttleMissionStatusRequest); }
      public:
        /// Constructor with default initializations
        ns3__PostTapingCollectShuttleMissionStatusRequest() : MissionNumber(), MissionStatus() { }
        virtual ~ns3__PostTapingCollectShuttleMissionStatusRequest() { }
        /// Friend allocator used by soap_new_ns3__PostTapingCollectShuttleMissionStatusRequest(struct soap*, int)
        friend SOAP_FMAC1 ns3__PostTapingCollectShuttleMissionStatusRequest * SOAP_FMAC2 soap_instantiate_ns3__PostTapingCollectShuttleMissionStatusRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:367 */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleReportRunningModeRequest
#define SOAP_TYPE_ns3__PostTapingCollectShuttleReportRunningModeRequest (59)
/* complex XML schema type 'ns3:PostTapingCollectShuttleReportRunningModeRequest': */
class SOAP_CMAC ns3__PostTapingCollectShuttleReportRunningModeRequest : public xsd__anyType {
      public:
        /// Optional element 'ns3:DefaultCode' of XML schema type 'xsd:int'
        int *DefaultCode;
        /// Optional element 'ns3:DefaultLabel' of XML schema type 'xsd:string'
        std::string *DefaultLabel;
        /// Optional element 'ns3:EquipmentCode' of XML schema type 'xsd:int'
        int *EquipmentCode;
        /// Optional element 'ns3:RunningMode' of XML schema type 'ns3:PostTapingCollectShuttleRunningModeType'
        enum ns3__PostTapingCollectShuttleRunningModeType *RunningMode;
        /// Optional element 'ns3:RunningModeDateTime' of XML schema type 'xsd:dateTime'
        time_t *RunningModeDateTime;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PostTapingCollectShuttleReportRunningModeRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__PostTapingCollectShuttleReportRunningModeRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PostTapingCollectShuttleReportRunningModeRequest, default initialized and not managed by a soap context
        virtual ns3__PostTapingCollectShuttleReportRunningModeRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__PostTapingCollectShuttleReportRunningModeRequest); }
      public:
        /// Constructor with default initializations
        ns3__PostTapingCollectShuttleReportRunningModeRequest() : DefaultCode(), DefaultLabel(), EquipmentCode(), RunningMode(), RunningModeDateTime() { }
        virtual ~ns3__PostTapingCollectShuttleReportRunningModeRequest() { }
        /// Friend allocator used by soap_new_ns3__PostTapingCollectShuttleReportRunningModeRequest(struct soap*, int)
        friend SOAP_FMAC1 ns3__PostTapingCollectShuttleReportRunningModeRequest * SOAP_FMAC2 soap_instantiate_ns3__PostTapingCollectShuttleReportRunningModeRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:958 */
#ifndef SOAP_TYPE___ns1__TapingOutputConveyorNumber
#define SOAP_TYPE___ns1__TapingOutputConveyorNumber (81)
/* Wrapper: */
struct SOAP_CMAC __ns1__TapingOutputConveyorNumber {
      public:
        /** Optional element 'ns1:TapingOutputConveyorNumber' of XML schema type 'ns1:TapingOutputConveyorNumber' */
        _ns1__TapingOutputConveyorNumber *ns1__TapingOutputConveyorNumber;
      public:
        /** Return unique type id SOAP_TYPE___ns1__TapingOutputConveyorNumber */
        long soap_type() const { return SOAP_TYPE___ns1__TapingOutputConveyorNumber; }
        /** Constructor with member initializations */
        __ns1__TapingOutputConveyorNumber() : ns1__TapingOutputConveyorNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__TapingOutputConveyorNumber * SOAP_FMAC2 soap_instantiate___ns1__TapingOutputConveyorNumber(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:1028 */
#ifndef SOAP_TYPE___ns1__MissionStatus
#define SOAP_TYPE___ns1__MissionStatus (85)
/* Wrapper: */
struct SOAP_CMAC __ns1__MissionStatus {
      public:
        /** Optional element 'ns1:MissionStatus' of XML schema type 'ns1:MissionStatus' */
        _ns1__MissionStatus *ns1__MissionStatus;
      public:
        /** Return unique type id SOAP_TYPE___ns1__MissionStatus */
        long soap_type() const { return SOAP_TYPE___ns1__MissionStatus; }
        /** Constructor with member initializations */
        __ns1__MissionStatus() : ns1__MissionStatus() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__MissionStatus * SOAP_FMAC2 soap_instantiate___ns1__MissionStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:1098 */
#ifndef SOAP_TYPE___ns1__ReportRunningMode
#define SOAP_TYPE___ns1__ReportRunningMode (89)
/* Wrapper: */
struct SOAP_CMAC __ns1__ReportRunningMode {
      public:
        /** Optional element 'ns1:ReportRunningMode' of XML schema type 'ns1:ReportRunningMode' */
        _ns1__ReportRunningMode *ns1__ReportRunningMode;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ReportRunningMode */
        long soap_type() const { return SOAP_TYPE___ns1__ReportRunningMode; }
        /** Constructor with member initializations */
        __ns1__ReportRunningMode() : ns1__ReportRunningMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__ReportRunningMode * SOAP_FMAC2 soap_instantiate___ns1__ReportRunningMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* client_collect.h:1313 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (90)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* client_collect.h:1313 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (91)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* client_collect.h:1313 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (93)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* client_collect.h:1313 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (96)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* client_collect.h:1313 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (97)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* client_collect.h:183 */
#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (16)
typedef char xsd__byte;
#endif

/* client_collect.h:186 */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (17)
typedef unsigned char xsd__unsignedByte;
#endif

/* client_collect.h:189 */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (18)
typedef std::string xsd__ID;
#endif

/* client_collect.h:199 */
#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (20)
typedef std::string xsd__IDREF;
#endif

/* client_collect.h:216 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (23)
typedef std::string xsd__anyURI;
#endif

/* client_collect.h:254 */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (31)
typedef std::string xsd__decimal;
#endif

/* client_collect.h:271 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (35)
typedef std::string xsd__duration;
#endif

/* client_collect.h:395 */
#ifndef SOAP_TYPE_ns2__char
#define SOAP_TYPE_ns2__char (60)
typedef int ns2__char;
#endif

/* client_collect.h:409 */
#ifndef SOAP_TYPE_ns2__duration
#define SOAP_TYPE_ns2__duration (62)
typedef std::string ns2__duration;
#endif

/* client_collect.h:422 */
#ifndef SOAP_TYPE_ns2__guid
#define SOAP_TYPE_ns2__guid (64)
typedef std::string ns2__guid;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* xsd__byte has binding name 'xsd__byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (16)
#endif

/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* short has binding name 'short' for type 'xsd:short' */
#ifndef SOAP_TYPE_short
#define SOAP_TYPE_short (43)
#endif

/* ns2__char has binding name 'ns2__char' for type 'ns2:char' */
#ifndef SOAP_TYPE_ns2__char
#define SOAP_TYPE_ns2__char (60)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* LONG64 has binding name 'LONG64' for type 'xsd:long' */
#ifndef SOAP_TYPE_LONG64
#define SOAP_TYPE_LONG64 (41)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (38)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (34)
#endif

/* xsd__unsignedByte has binding name 'xsd__unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (17)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (14)
#endif

/* unsigned short has binding name 'unsignedShort' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_unsignedShort
#define SOAP_TYPE_unsignedShort (50)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (13)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (48)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (30)
#endif

/* enum ns3__PostTapingCollectShuttleRunningModeType has binding name 'ns3__PostTapingCollectShuttleRunningModeType' for type 'ns3:PostTapingCollectShuttleRunningModeType' */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleRunningModeType
#define SOAP_TYPE_ns3__PostTapingCollectShuttleRunningModeType (68)
#endif

/* enum ns3__PostTapingCollectShuttleMissionStatusType has binding name 'ns3__PostTapingCollectShuttleMissionStatusType' for type 'ns3:PostTapingCollectShuttleMissionStatusType' */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusType
#define SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusType (66)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (27)
#endif

/* ns3__PostTapingCollectShuttleRunningModeType_ has binding name 'ns3__PostTapingCollectShuttleRunningModeType_' for type 'ns3:PostTapingCollectShuttleRunningModeType' */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleRunningModeType_
#define SOAP_TYPE_ns3__PostTapingCollectShuttleRunningModeType_ (69)
#endif

/* ns3__PostTapingCollectShuttleMissionStatusType_ has binding name 'ns3__PostTapingCollectShuttleMissionStatusType_' for type 'ns3:PostTapingCollectShuttleMissionStatusType' */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusType_
#define SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusType_ (67)
#endif

/* ns2__guid__ has binding name 'ns2__guid__' for type 'ns2:guid' */
#ifndef SOAP_TYPE_ns2__guid__
#define SOAP_TYPE_ns2__guid__ (65)
#endif

/* ns2__guid has binding name 'ns2__guid' for type 'ns2:guid' */
#ifndef SOAP_TYPE_ns2__guid
#define SOAP_TYPE_ns2__guid (64)
#endif

/* ns2__duration__ has binding name 'ns2__duration__' for type 'ns2:duration' */
#ifndef SOAP_TYPE_ns2__duration__
#define SOAP_TYPE_ns2__duration__ (63)
#endif

/* ns2__duration has binding name 'ns2__duration' for type 'ns2:duration' */
#ifndef SOAP_TYPE_ns2__duration
#define SOAP_TYPE_ns2__duration (62)
#endif

/* ns2__char__ has binding name 'ns2__char__' for type 'ns2:char' */
#ifndef SOAP_TYPE_ns2__char__
#define SOAP_TYPE_ns2__char__ (61)
#endif

/* ns3__PostTapingCollectShuttleReportRunningModeRequest has binding name 'ns3__PostTapingCollectShuttleReportRunningModeRequest' for type 'ns3:PostTapingCollectShuttleReportRunningModeRequest' */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleReportRunningModeRequest
#define SOAP_TYPE_ns3__PostTapingCollectShuttleReportRunningModeRequest (59)
#endif

/* ns3__PostTapingCollectShuttleMissionStatusRequest has binding name 'ns3__PostTapingCollectShuttleMissionStatusRequest' for type 'ns3:PostTapingCollectShuttleMissionStatusRequest' */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusRequest
#define SOAP_TYPE_ns3__PostTapingCollectShuttleMissionStatusRequest (58)
#endif

/* ns3__PostTapingCollectShuttleTapingOutputConveyorRequest has binding name 'ns3__PostTapingCollectShuttleTapingOutputConveyorRequest' for type 'ns3:PostTapingCollectShuttleTapingOutputConveyorRequest' */
#ifndef SOAP_TYPE_ns3__PostTapingCollectShuttleTapingOutputConveyorRequest
#define SOAP_TYPE_ns3__PostTapingCollectShuttleTapingOutputConveyorRequest (57)
#endif

/* _ns1__ReportRunningModeResponse has binding name '_ns1__ReportRunningModeResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ReportRunningModeResponse
#define SOAP_TYPE__ns1__ReportRunningModeResponse (56)
#endif

/* _ns1__ReportRunningMode has binding name '_ns1__ReportRunningMode' for type '' */
#ifndef SOAP_TYPE__ns1__ReportRunningMode
#define SOAP_TYPE__ns1__ReportRunningMode (55)
#endif

/* _ns1__MissionStatusResponse has binding name '_ns1__MissionStatusResponse' for type '' */
#ifndef SOAP_TYPE__ns1__MissionStatusResponse
#define SOAP_TYPE__ns1__MissionStatusResponse (54)
#endif

/* _ns1__MissionStatus has binding name '_ns1__MissionStatus' for type '' */
#ifndef SOAP_TYPE__ns1__MissionStatus
#define SOAP_TYPE__ns1__MissionStatus (53)
#endif

/* _ns1__TapingOutputConveyorNumberResponse has binding name '_ns1__TapingOutputConveyorNumberResponse' for type '' */
#ifndef SOAP_TYPE__ns1__TapingOutputConveyorNumberResponse
#define SOAP_TYPE__ns1__TapingOutputConveyorNumberResponse (52)
#endif

/* _ns1__TapingOutputConveyorNumber has binding name '_ns1__TapingOutputConveyorNumber' for type '' */
#ifndef SOAP_TYPE__ns1__TapingOutputConveyorNumber
#define SOAP_TYPE__ns1__TapingOutputConveyorNumber (51)
#endif

/* xsd__unsignedShort_ has binding name 'xsd__unsignedShort_' for type 'xsd:unsignedShort' */
#ifndef SOAP_TYPE_xsd__unsignedShort_
#define SOAP_TYPE_xsd__unsignedShort_ (49)
#endif

/* xsd__unsignedLong_ has binding name 'xsd__unsignedLong_' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_xsd__unsignedLong_
#define SOAP_TYPE_xsd__unsignedLong_ (47)
#endif

/* xsd__unsignedInt_ has binding name 'xsd__unsignedInt_' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_xsd__unsignedInt_
#define SOAP_TYPE_xsd__unsignedInt_ (46)
#endif

/* xsd__unsignedByte__ has binding name 'xsd__unsignedByte__' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_xsd__unsignedByte__
#define SOAP_TYPE_xsd__unsignedByte__ (45)
#endif

/* xsd__string_ has binding name 'xsd__string_' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string_
#define SOAP_TYPE_xsd__string_ (44)
#endif

/* xsd__short_ has binding name 'xsd__short_' for type 'xsd:short' */
#ifndef SOAP_TYPE_xsd__short_
#define SOAP_TYPE_xsd__short_ (42)
#endif

/* xsd__long_ has binding name 'xsd__long_' for type 'xsd:long' */
#ifndef SOAP_TYPE_xsd__long_
#define SOAP_TYPE_xsd__long_ (40)
#endif

/* xsd__int_ has binding name 'xsd__int_' for type 'xsd:int' */
#ifndef SOAP_TYPE_xsd__int_
#define SOAP_TYPE_xsd__int_ (39)
#endif

/* xsd__float_ has binding name 'xsd__float_' for type 'xsd:float' */
#ifndef SOAP_TYPE_xsd__float_
#define SOAP_TYPE_xsd__float_ (37)
#endif

/* xsd__duration__ has binding name 'xsd__duration__' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration__
#define SOAP_TYPE_xsd__duration__ (36)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (35)
#endif

/* xsd__double_ has binding name 'xsd__double_' for type 'xsd:double' */
#ifndef SOAP_TYPE_xsd__double_
#define SOAP_TYPE_xsd__double_ (33)
#endif

/* xsd__decimal__ has binding name 'xsd__decimal__' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal__
#define SOAP_TYPE_xsd__decimal__ (32)
#endif

/* xsd__decimal has binding name 'xsd__decimal' for type 'xsd:decimal' */
#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (31)
#endif

/* xsd__dateTime_ has binding name 'xsd__dateTime_' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime_
#define SOAP_TYPE_xsd__dateTime_ (29)
#endif

/* xsd__byte__ has binding name 'xsd__byte__' for type 'xsd:byte' */
#ifndef SOAP_TYPE_xsd__byte__
#define SOAP_TYPE_xsd__byte__ (28)
#endif

/* xsd__boolean_ has binding name 'xsd__boolean_' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean_
#define SOAP_TYPE_xsd__boolean_ (26)
#endif

/* xsd__base64Binary__ has binding name 'xsd__base64Binary__' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary__
#define SOAP_TYPE_xsd__base64Binary__ (25)
#endif

/* xsd__anyURI__ has binding name 'xsd__anyURI__' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI__
#define SOAP_TYPE_xsd__anyURI__ (24)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (23)
#endif

/* xsd__QName__ has binding name 'xsd__QName__' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName__
#define SOAP_TYPE_xsd__QName__ (22)
#endif

/* xsd__IDREF__ has binding name 'xsd__IDREF__' for type 'xsd:IDREF' */
#ifndef SOAP_TYPE_xsd__IDREF__
#define SOAP_TYPE_xsd__IDREF__ (21)
#endif

/* xsd__IDREF has binding name 'xsd__IDREF' for type 'xsd:IDREF' */
#ifndef SOAP_TYPE_xsd__IDREF
#define SOAP_TYPE_xsd__IDREF (20)
#endif

/* xsd__ID__ has binding name 'xsd__ID__' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID__
#define SOAP_TYPE_xsd__ID__ (19)
#endif

/* xsd__ID has binding name 'xsd__ID' for type 'xsd:ID' */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (18)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (12)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (11)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (10)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (97)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (96)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (93)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (91)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (90)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (99)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (98)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (92)
#endif

/* _ns1__ReportRunningMode * has binding name 'PointerTo_ns1__ReportRunningMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ReportRunningMode
#define SOAP_TYPE_PointerTo_ns1__ReportRunningMode (86)
#endif

/* _ns1__MissionStatus * has binding name 'PointerTo_ns1__MissionStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__MissionStatus
#define SOAP_TYPE_PointerTo_ns1__MissionStatus (82)
#endif

/* _ns1__TapingOutputConveyorNumber * has binding name 'PointerTo_ns1__TapingOutputConveyorNumber' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__TapingOutputConveyorNumber
#define SOAP_TYPE_PointerTo_ns1__TapingOutputConveyorNumber (78)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (77)
#endif

/* enum ns3__PostTapingCollectShuttleRunningModeType * has binding name 'PointerTons3__PostTapingCollectShuttleRunningModeType' for type 'ns3:PostTapingCollectShuttleRunningModeType' */
#ifndef SOAP_TYPE_PointerTons3__PostTapingCollectShuttleRunningModeType
#define SOAP_TYPE_PointerTons3__PostTapingCollectShuttleRunningModeType (76)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (75)
#endif

/* enum ns3__PostTapingCollectShuttleMissionStatusType * has binding name 'PointerTons3__PostTapingCollectShuttleMissionStatusType' for type 'ns3:PostTapingCollectShuttleMissionStatusType' */
#ifndef SOAP_TYPE_PointerTons3__PostTapingCollectShuttleMissionStatusType
#define SOAP_TYPE_PointerTons3__PostTapingCollectShuttleMissionStatusType (74)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (73)
#endif

/* ns3__PostTapingCollectShuttleReportRunningModeRequest * has binding name 'PointerTons3__PostTapingCollectShuttleReportRunningModeRequest' for type 'ns3:PostTapingCollectShuttleReportRunningModeRequest' */
#ifndef SOAP_TYPE_PointerTons3__PostTapingCollectShuttleReportRunningModeRequest
#define SOAP_TYPE_PointerTons3__PostTapingCollectShuttleReportRunningModeRequest (72)
#endif

/* ns3__PostTapingCollectShuttleMissionStatusRequest * has binding name 'PointerTons3__PostTapingCollectShuttleMissionStatusRequest' for type 'ns3:PostTapingCollectShuttleMissionStatusRequest' */
#ifndef SOAP_TYPE_PointerTons3__PostTapingCollectShuttleMissionStatusRequest
#define SOAP_TYPE_PointerTons3__PostTapingCollectShuttleMissionStatusRequest (71)
#endif

/* ns3__PostTapingCollectShuttleTapingOutputConveyorRequest * has binding name 'PointerTons3__PostTapingCollectShuttleTapingOutputConveyorRequest' for type 'ns3:PostTapingCollectShuttleTapingOutputConveyorRequest' */
#ifndef SOAP_TYPE_PointerTons3__PostTapingCollectShuttleTapingOutputConveyorRequest
#define SOAP_TYPE_PointerTons3__PostTapingCollectShuttleTapingOutputConveyorRequest (70)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (15)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
